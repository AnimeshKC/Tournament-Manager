import { assignSeedValues, SeedObject } from "./assignSeed.singleElim";

export interface MatchMemberList {
  seedValue: number;
  roundEliminated?: number;
  participantName?: string;
  userId?: number;
  tournId: number;
  round: number;
  [propName: string]: any;
}

export interface MatchObject {
  userId1?: number;
  participantName1?: string;
  userId2?: number;
  participantName2?: string;
  tournId: number;
  round: number;
}
//throws an error if round isn't valid for the number of members
//Ex. A round 3 is only possible if more than 4 members are in the tournament
function validateNaturalNumber(num: number) {
  const validRound = Number.isInteger(num) && num > 0;
  if (!validRound) throw new Error("Invalid Round");
}

function validateRoundForSize(round: number, memberSize: number) {
  validateNaturalNumber(round);
  if (memberSize * 2 <= Math.pow(2, round))
    throw new Error("Round exceeds bound for this size of members");
}

function getRoundValue(round: number, seed: number) {
  validateNaturalNumber(round);
  validateNaturalNumber(seed);
  return Math.ceil(seed / Math.pow(2, round - 1));
}

//TODO: add a filter to take out the eliminated members in future rounds
//assumes memberList has seed values generated by assignSeedValues
function assignMatches(memberList: MatchMemberList[], round: number) {
  const memberSize = memberList.length;
  validateRoundForSize(round, memberSize);
  memberList.sort((member1, member2) => member1.seedValue - member2.seedValue);
  let i = 0;
  const matches: MatchObject[] = [];
  while (i < memberSize) {
    const leftMember = memberList[i];
    const {
      tournId,
      userId: userId1,
      participantName: participantName1,
      seedValue: leftSeed,
    } = leftMember;
    //if i is the last index, leftMember has no pair
    if (i + 1 === memberSize)
      matches.push({
        tournId,
        userId1,
        participantName1,
        participantName2: null,
        userId2: null,
        round,
      });

    const leftRoundValue = getRoundValue(round, leftSeed);
    const rightMember = memberList[i + 1];
    const {
      seedValue: rightSeed,
      userId: userId2,
      participantName: participantName2,
    } = rightMember;
    const rightRoundValue = getRoundValue(round, rightSeed);

    const isAMatch = leftRoundValue === rightRoundValue - 1;
    if (isAMatch) {
      matches.push({
        userId1,
        participantName1,
        participantName2,
        userId2,
        tournId,
        round,
      });
      i += 2;
    } else {
      matches.push({
        tournId,
        userId1,
        participantName1,
        participantName2: null,
        userId2: null,
        round,
      });
    }
    //since  the right member was not a match, need to check it
    //TODO: The way the logic works, once one of the leftMembers do not have a match, none do, so this can be simplified with a function
    i++;
  }
  // while (i < memberSize) {
  //   if()
  const member = memberList[i];
  //   if (i+1 < memberSize && memberList[i+1].roundEliminated? >)
  const seedValue = member.seedValue;
  i++;
}

const memberList: SeedObject[] = [
  { participantName: "p1" },
  { participantName: "p2" },
  { participantName: "p3" },
  { participantName: "p4" },
  { participantName: "p5" },
  //   { userId: 6 },
  //   { participantName: "p7" },
  //   { userId: 8 },
];

const seededMemberList: MatchMemberList[] = memberList.map(member => ({
  ...member,
  seedValue: 0,
  round: 1,
  tournId: 1,
}));

assignSeedValues(seededMemberList);

assignMatches(seededMemberList, 1);
console.log(seededMemberList);
for (const member of seededMemberList) {
  console.log(
    getRoundValue(1, member.seedValue),
    getRoundValue(2, member.seedValue),
    getRoundValue(3, member.seedValue),
  );
}
